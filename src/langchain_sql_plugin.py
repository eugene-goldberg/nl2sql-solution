"""
LangChain SQL Plugin for Semantic Kernel

This module implements a Semantic Kernel plugin that leverages LangChain's 
SQL capabilities to translate natural language queries into T-SQL for Azure SQL databases.
"""

import os
import logging
from typing import List, Dict, Any, Optional, Union

import semantic_kernel as sk
from semantic_kernel.functions import kernel_function
from dotenv import load_dotenv
from langchain_openai import AzureChatOpenAI
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_community.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain_community.agent_toolkits.sql.base import create_sql_agent
from langchain.agents.agent_types import AgentType
from langchain.callbacks.base import BaseCallbackHandler

from .database import DatabaseManager
from .security import SecurityValidator

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SQLQueryCallbackHandler(BaseCallbackHandler):
    """Callback handler for logging SQL queries generated by LangChain."""
    
    def __init__(self):
        self.sql_queries = []
    
    def on_llm_start(self, serialized, prompts, **kwargs):
        """Log when LLM starts."""
        logger.debug(f"LLM started with prompts: {prompts}")
    
    def on_tool_start(self, serialized, input_str, **kwargs):
        """Log when a tool starts, capturing SQL queries."""
        tool_name = kwargs.get("name", "unknown_tool")
        if tool_name in ["sql_db_query", "sql_db_schema", "sql_db_list_tables"]:
            logger.info(f"SQL Tool '{tool_name}' started with input: {input_str}")
            if "SELECT" in input_str.upper() or "INSERT" in input_str.upper() or "UPDATE" in input_str.upper() or "DELETE" in input_str.upper():
                self.sql_queries.append(input_str)
                logger.info(f"Captured SQL query: {input_str}")

class LangChainSqlPlugin:
    """
    Semantic Kernel plugin that uses LangChain to translate natural language to SQL.
    
    This plugin connects to an Azure SQL database and leverages LangChain's SQL agent
    capabilities to generate and execute T-SQL queries from natural language.
    """
    
    def __init__(self, connection_string: Optional[str] = None, 
                 azure_openai_api_key: Optional[str] = None,
                 azure_openai_endpoint: Optional[str] = None,
                 azure_openai_api_version: Optional[str] = None,
                 azure_openai_deployment_name: Optional[str] = None,
                 included_tables: Optional[List[str]] = None,
                 read_only: bool = True,
                 include_image_columns: bool = False):
        """
        Initialize the LangChain SQL Plugin.
        
        Args:
            connection_string: Azure SQL connection string. If None, reads from env vars.
            azure_openai_api_key: Azure OpenAI API key. If None, reads from env vars.
            azure_openai_endpoint: Azure OpenAI endpoint. If None, reads from env vars.
            azure_openai_api_version: Azure OpenAI API version. If None, reads from env vars.
            azure_openai_deployment_name: Azure OpenAI deployment name. If None, reads from env vars.
            included_tables: List of tables to include. If None, reads from env vars or includes all.
            read_only: Whether the database connection should be read-only.
        """
        # Load environment variables
        load_dotenv()
        
        # Set up Azure OpenAI configuration
        self.azure_openai_api_key = azure_openai_api_key or os.getenv("AZURE_OPENAI_API_KEY")
        self.azure_openai_endpoint = azure_openai_endpoint or os.getenv("AZURE_OPENAI_ENDPOINT")
        self.azure_openai_api_version = azure_openai_api_version or os.getenv("AZURE_OPENAI_API_VERSION")
        self.azure_openai_deployment_name = azure_openai_deployment_name or os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")
        
        # Set up Azure SQL configuration
        self.connection_string = connection_string or os.getenv("AZURE_SQL_CONNECTION_STRING")
        
        # Parse included tables from env if not provided
        if included_tables is None:
            included_tables_str = os.getenv("INCLUDED_TABLES", "")
            self.included_tables = [t.strip() for t in included_tables_str.split(",")] if included_tables_str else None
        else:
            self.included_tables = included_tables
            
        # Set up security validator
        self.read_only = read_only
        self.include_image_columns = include_image_columns
        self.security_validator = SecurityValidator(read_only=read_only)
        
        # Validate configuration
        self._validate_config()
        
        # Initialize database manager and LangChain components
        self._setup_database_and_langchain()
        
    def _validate_config(self):
        """Validate that all required configuration is present."""
        missing = []
        
        if not self.azure_openai_api_key:
            missing.append("AZURE_OPENAI_API_KEY")
        if not self.azure_openai_endpoint:
            missing.append("AZURE_OPENAI_ENDPOINT")
        if not self.azure_openai_api_version:
            missing.append("AZURE_OPENAI_API_VERSION")
        if not self.azure_openai_deployment_name:
            missing.append("AZURE_OPENAI_DEPLOYMENT_NAME")
        if not self.connection_string:
            missing.append("AZURE_SQL_CONNECTION_STRING")
            
        if missing:
            raise ValueError(f"Missing required configuration: {', '.join(missing)}")
    
    def _setup_database_and_langchain(self):
        """Set up the database manager and LangChain components."""
        # Initialize Azure OpenAI
        self.llm = AzureChatOpenAI(
            azure_deployment=self.azure_openai_deployment_name,
            openai_api_version=self.azure_openai_api_version,
            azure_endpoint=self.azure_openai_endpoint,
            api_key=self.azure_openai_api_key,
            temperature=0
        )
        
        # Initialize database manager
        self.db_manager = DatabaseManager(
            connection_string=self.connection_string,
            included_tables=self.included_tables,
            sample_rows_in_table_info=3,
            include_image_columns=self.include_image_columns
        )
        
        # Get the LangChain SQLDatabase instance from the manager
        self.db = self.db_manager.get_langchain_db()
        
        # Create SQL toolkit
        self.sql_toolkit = SQLDatabaseToolkit(
            db=self.db,
            llm=self.llm
        )
        
        # Set up the callback handler for logging
        self.callback_handler = SQLQueryCallbackHandler()
        
        # Create the SQL agent
        self.agent = create_sql_agent(
            llm=self.llm,
            toolkit=self.sql_toolkit,
            agent_type=AgentType.OPENAI_FUNCTIONS,
            verbose=True,
            agent_executor_kwargs={"callbacks": [self.callback_handler]}
        )
        
        logger.info("LangChain SQL Agent initialized successfully")

    @kernel_function(
        description="Translates a natural language query into SQL and executes it against an Azure SQL database",
        name="query_database"
    )
    def query_database_with_natural_language(self, natural_language_query: str) -> str:
        """
        Translate a natural language query to SQL and execute it against the database.
        
        Args:
            natural_language_query: The natural language query to translate to SQL.
            
        Returns:
            The result of the SQL query, formatted as a string.
        """
        if not natural_language_query:
            return "Error: Empty query provided."
        
        try:
            logger.info(f"Processing natural language query: {natural_language_query}")
            
            # Validate the natural language input
            is_valid, error_message = self.security_validator.validate_nl_input(natural_language_query)
            if not is_valid:
                logger.warning(f"Security validation failed for query: {error_message}")
                return f"Error: Security validation failed. {error_message}"
            
            # Sanitize the input (this is a basic defense layer)
            sanitized_query = self.security_validator.sanitize_nl_input(natural_language_query)
            if sanitized_query != natural_language_query:
                logger.info("Natural language query was sanitized before processing")
            
            # Reset the callback handler's query list
            self.callback_handler.sql_queries = []
            
            # Execute the query using the LangChain SQL agent
            result = self.agent.invoke({"input": sanitized_query})
            
            # Get the SQL queries captured during execution
            sql_queries = self.callback_handler.sql_queries
            if sql_queries:
                logger.info(f"SQL Queries Generated: {sql_queries}")
                
                # Validate each SQL query for security concerns (optional validation)
                # Note: LangChain already executes the query and the primary security
                # defense is the least-privilege database user
                for sql_query in sql_queries:
                    is_valid, error_message = self.security_validator.validate_sql_query(sql_query)
                    if not is_valid:
                        logger.warning(f"Generated SQL query failed security validation: {error_message}")
                        # We log but don't block here since LangChain already executed it
                
                # Create audit record
                audit_record = self.security_validator.audit_query(
                    nl_query=natural_language_query,
                    sql_query="\n".join(sql_queries),
                    result_status="success"
                )
                logger.info(f"Audit record: {audit_record}")
            
            # Format and return the result
            return result["output"]
        
        except Exception as e:
            error_message = f"Error processing query: {str(e)}"
            logger.error(error_message)
            
            # Create audit record for the error
            if hasattr(self, 'security_validator'):
                audit_record = self.security_validator.audit_query(
                    nl_query=natural_language_query,
                    sql_query="<error>",
                    result_status=f"error: {str(e)}"
                )
                logger.info(f"Audit record: {audit_record}")
                
            return error_message